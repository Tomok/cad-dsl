# CAD-DSL - Claude Projekt-Kontext

## Projektübersicht

Dies ist eine Domain-Specific Language (DSL) für CAD (Computer-Aided Design), geschrieben in Rust. Das Projekt verwendet den Chumsky Parser-Combinator und Logos für Lexing.

## Aktueller Stand

### Implementiert ✅
- **Lexer** (`src/lexer.rs`): Vollständig implementiert mit Logos
  - Alle Keywords, Operatoren, Punktuation, Built-in Types
  - Position & Span Tracking
  - Kommentare (einzeilig und mehrzeilig)

- **Expression Parser** (`src/parser.rs`): Grundlegende arithmetische Ausdrücke
  - Integer/Float Literale, Variablen
  - Addition, Subtraktion, Multiplikation, Division
  - Operator-Präzedenz und Links-Assoziativität
  - Parenthesen
  - Ariadne Error Reporting

- **AST** (`src/ast.rs`): Expression-Typen mit Type-Safe Präzedenz
  - Verwendet `subenum` für hierarchische Typen
  - `Expr`, `AddLhs`, `AddRhs`, `MulLhs`, `MulRhs`, `Atom`

### Noch zu implementieren ❌
- Statements (let, return, assignments, etc.)
- Control Flow (if/else, for loops, with statements)
- Funktionsdefinitionen und -aufrufe
- Struct & Container Definitionen
- Boolesche & Vergleichsausdrücke
- Typ-System vollständig parsen

Siehe `AST_PARSING_TODO.md` für eine detaillierte Checkliste.

## Architektur

```
src/
├── lexer.rs    - Logos-basierter Tokenizer
├── parser.rs   - Chumsky Parser (nur Expressions aktuell)
├── ast.rs      - AST-Definitionen (nur Expressions)
└── main.rs     - CLI mit `parse` Befehl
```

## Wichtige Design-Entscheidungen

1. **Type-Safe Operator Precedence**: Der AST verwendet separate Typen (`AddLhs`, `AddRhs`, `MulLhs`, `MulRhs`) um Präzedenz auf Typ-Ebene zu erzwingen.

2. **Ariadne Error Reporting**: Parser-Fehler werden mit schönen, farbigen Ariadne-Reports ausgegeben.

3. **Position Tracking**: Alle Tokens haben Line/Column Information für präzise Fehlermeldungen.

## Dependencies

- **chumsky**: Parser Combinator Library
- **logos**: Fast Lexer Generator
- **ariadne**: Beautiful Error Reporting
- **subenum**: Macro für Sub-Enums

## Entwicklung

### Tests ausführen
```bash
cargo test
```

### Parser ausprobieren
```bash
cargo run -- parse "1 + 2 * 3"
```

### Build
```bash
cargo build --release
```

## Nächste Schritte

1. Erweitere den Parser um boolesche Ausdrücke
2. Implementiere Statement-Parsing
3. Füge Funktionsdefinitionen hinzu
4. Implementiere Control Flow (if/else, for)
5. Struct & Container Definitionen

## Coding-Stil

- Verwende `//!` für Module-level Dokumentation
- Verwende `///` für Item-level Dokumentation
- Gruppiere Code mit `// ====...====` Kommentaren
- Teste alle Features mit Unit Tests
- Verwende `#[derive(Debug, Clone, PartialEq)]` für AST-Typen

## Git Workflow

- Branch: `claude/ast-parsing-todo-setup-CBR3o`
- Main branch für PRs: (wird noch konfiguriert)
- Verwende descriptive commit messages
- Teste vor commits mit `cargo test`
